<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ZAIN.NET Crypto Futures – LONG/SHORT (Client-only, Improved)</title>
<script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
:root{--bg:#071024;--card:#0f1724;--muted:#9fb0c8;--text:#e6f2ff;--accent:#22c55e;--danger:#ff6b6b}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Roboto,Helvetica,Arial}
.wrap{max-width:1200px;margin:14px auto;padding:12px}
header{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
h1{font-size:18px;margin:0}
.controls{display:grid;grid-template-columns:repeat(12,1fr);gap:8px;width:100%}
.c{grid-column:auto/span 3}
@media(max-width:900px){.c{grid-column:auto/span 6}}
@media(max-width:600px){.c{grid-column:auto/span 12}}
input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid #21324a;background:#071822;color:var(--text)}
button{cursor:pointer}
button.primary{background:linear-gradient(180deg,#0b6b4f,#0a5a42);border:none;color:#e9fff1}
.grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.card{background:var(--card);border-radius:12px;padding:12px;border:1px solid #122033}
#chart{height:360px}
.list{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
@media(max-width:980px){.list{grid-template-columns:1fr}}
.coin{padding:10px;border-radius:10px;border:1px solid #17283a;background:linear-gradient(180deg,#071422,#081826);display:flex;flex-direction:column;gap:8px}
.pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px}
.pill.long{background:#063;color:#bfffe0}
.pill.short{background:#600;color:#ffdede}
.pill.neutral{background:#30343a;color:#cbd5e1}
.muted{color:var(--muted);font-size:13px}
.small{font-size:12px;color:#9fb0c8}
.kpi{display:flex;gap:8px;flex-wrap:wrap}
.kpi .box{background:#071826;padding:8px;border-radius:8px;border:1px solid #123045}
.history{max-height:240px;overflow:auto;font-size:13px;white-space:pre-wrap}
.footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
button.small{padding:6px 8px;font-size:13px}
.warn{color:#ffcf66}
.signal-desc{font-size:12px;color:#a0c0ff;margin-top:2px}
.toggle-box{display:flex;gap:6px;flex-wrap:wrap;font-size:12px}
.toggle-box label{display:flex;align-items:center;gap:4px}
#log{white-space:pre-wrap}
</style>
</head>
<body>
<div class="wrap">
<header>
<h1>ZAIN.NET Crypto Futures – WA (085231176597)</h1>
<div class="small muted">Futures USDT-M • EMA/RSI/MACD/BB • Fibonacci • Golden Cross • Chart • History • CORS-hardened</div>
</header>

<section class="card controls" style="margin-bottom:12px">
<div class="c"><label>Timeframe<select id="tf"><option>1m</option><option>3m</option><option>5m</option><option>15m</option><option selected>1h</option><option>4h</option><option>1d</option></select></label></div>
<div class="c"><label>Jumlah candle<input id="limit" type="number" min="50" max="1000" value="300"></label></div>
<div class="c"><label>Interval (detik)<input id="interval" type="number" min="5" value="60"></label></div>
<div class="c"><label>Top N USDT<input id="topN" type="number" min="5" max="100" value="30"></label></div>
<div class="c"><label>Modal (USD)<input id="capital" type="number" value="1000"></label></div>
<div class="c"><label>Risk (%)<input id="risk" type="number" step="0.1" value="1.0"></label></div>
<div class="c"><label>Filter<select id="filter"><option value="all">Semua</option><option value="long">LONG</option><option value="short">SHORT</option><option value="neutral">NEUTRAL</option></select></label></div>
<div class="c"><label>Sort<select id="sort"><option value="volume">Volume</option><option value="change">%Change</option><option value="score">Score</option><option value="symbol">Symbol</option></select></label></div>
<div class="c"><label>Search<input id="search" placeholder="BTC, ETH..." /></label></div>
<div class="c"><label>Concurrency<input id="concurrency" type="number" min="1" max="12" value="6"></label></div>

<div class="c" style="grid-column:span 12">
  <div class="toggle-box">
    <label><input type="checkbox" id="useEMA" checked>EMA</label>
    <label><input type="checkbox" id="useRSI" checked>RSI</label>
    <label><input type="checkbox" id="useMACD" checked>MACD</label>
    <label><input type="checkbox" id="useBB" checked>BB</label>
    <label><input type="checkbox" id="useFIB" checked>Fibonacci</label>
  </div>
</div>

<div class="c"><button class="primary" id="startBtn">Start Scan</button></div>
<div class="c"><button id="stopBtn">Stop</button></div>
<div class="c"><button id="exportCSV">Export CSV</button></div>
<div class="c"><button id="exportJSON">Export JSON</button></div>
</section>

<div class="grid">
<div>
<div class="card">
<div style="display:flex;justify-content:space-between;align-items:center">
<div class="kpi" id="kpis"></div>
<div><span class="small muted">Status: </span><span id="status" class="small">Idle</span></div>
</div>
<div id="warn" class="small warn" style="margin-top:6px"></div>
<div id="list" class="list" style="margin-top:12px"></div>
</div>

<div class="card" style="margin-top:12px">
<h3>History (localStorage)</h3>
<div style="display:flex;gap:8px;margin-bottom:8px">
<button id="clearHistory" class="small">Clear History</button>
<button id="downloadHistory" class="small">Download JSON</button>
</div>
<div id="history" class="history muted"></div>
</div>
</div>

<div>
<div class="card">
<h3>Chart</h3>
<div id="chart"></div>
<div id="chartInfo" class="small muted" style="margin-top:8px"></div>
</div>

<div class="card" style="margin-top:12px">
<h3>Logs</h3>
<div id="log" class="small muted" style="max-height:160px;overflow:auto"></div>
</div>
</div>
</div>

<div class="footer">DYOR. Ini hanya analisa otomatis yang bisa saja salah. Analisa manual lagi untuk validasi data.</div>
</div>

<script>
// ======== UTILITIES ========
const DOM=s=>document.querySelector(s);
const fmt=(n,d=2)=>Number(n).toLocaleString(undefined,{maximumFractionDigits:d});
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
const PROXY='https://api.allorigins.win/raw?url=';

// ======== ALARM (unlock on user click) ========
const alarm = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
let audioUnlocked = false;
function unlockAudioOnce(){
  if(audioUnlocked) return;
  // try quick muted play to satisfy gesture policies
  alarm.muted = true;
  alarm.play().catch(()=>{}).finally(()=>{ alarm.pause(); alarm.muted = false; audioUnlocked = true; });
}
function playAlarm(){
  try{ if(audioUnlocked) alarm.play(); else { /* in case not unlocked, still try */ alarm.play().catch(()=>{}); } } catch(e){}
}

// ======== FETCH with proxy fallback ========
async function tryFetch(url,retries=2){
  const tries=[url, PROXY+encodeURIComponent(url)];
  let lastErr=null;
  for(const u of tries){
    for(let i=0;i<=retries;i++){
      try{
        const r = await fetch(u, {cache:'no-store'});
        if(!r.ok) throw new Error(`HTTP ${r.status}`);
        const json = await r.json();
        log(`fetched ${u}`);
        return json;
      }catch(e){ lastErr = e; await sleep(300*(i+1)); }
    }
  }
  throw lastErr;
}

// ======== INDICATORS (same as before) ========
function SMA(data,p){const out=[];let s=0;for(let i=0;i<data.length;i++){s+=data[i];if(i>=p)s-=data[i-p];out.push(i>=p-1?s/p:null);}return out;}
function EMA(arr,p){const out=[];const k=2/(p+1);let prev=null;for(let i=0;i<arr.length;i++){prev = prev===null?arr[i]:(arr[i]-prev)*k+prev;out.push(prev);}return out;}
function RSI(closes,p=14){const out=Array(closes.length).fill(null);let g=0,l=0;for(let i=1;i<closes.length;i++){const d=closes[i]-closes[i-1];const gg=Math.max(d,0),ll=Math.max(-d,0);if(i<=p){g+=gg;l+=ll;if(i===p){const rs=g/Math.max(l,1e-9);out[i]=100-100/(1+rs);}}else{g=(g*(p-1)+gg)/p;l=(l*(p-1)+ll)/p;const rs=g/Math.max(l,1e-9);out[i]=100-100/(1+rs);}}return out;}
function MACD(closes,f=12,s=26,sig=9){const emaF=EMA(closes,f), emaS=EMA(closes,s); const macd=emaF.map((v,i)=>v-emaS[i]); const sigLine=EMA(macd,sig); return {macd, sig: sigLine, hist: macd.map((v,i)=>v-sigLine[i])};}
function BB(closes,p=20,mul=2){const sma=SMA(closes,p); return closes.map((c,i)=>{ if(i<p-1) return null; const slice=closes.slice(i-p+1,i+1); const mean=sma[i]; const sd=Math.sqrt(slice.reduce((a,b)=>a+(b-mean)**2,0)/p); return {upper:mean+mul*sd, mid:mean, lower:mean-mul*sd}; }); }

// ======== CHART (init once) ========
let chart=null, series=null, ema50Series=null, ema200Series=null, bbUpper=null, bbLower=null;
let supportSeries=null, resistanceSeries=null, patternSeries=null;
let globalMarkers = []; // collect markers, updated each scan (limited size)
function initChart(){
  if(chart) return;
  chart = LightweightCharts.createChart(DOM('#chart'), { width: 760, height: 360, rightPriceScale:{borderVisible:false}, timeScale:{borderVisible:false} });
  series = chart.addCandlestickSeries();
  ema50Series = chart.addLineSeries({ color: 'yellow', lineWidth: 2 });
  ema200Series = chart.addLineSeries({ color: 'orange', lineWidth: 2 });
  bbUpper = chart.addLineSeries({ color: 'cyan', lineWidth: 1 });
  bbLower = chart.addLineSeries({ color: 'cyan', lineWidth: 1 });
  supportSeries = chart.addLineSeries({ color: 'lime', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dotted });
  resistanceSeries = chart.addLineSeries({ color: 'orange', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dotted });
  patternSeries = chart.addLineSeries({ color: '#888', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed });
}

// ======== MARKERS helper (append, avoid unlimited growth) ========
function pushMarker(m){
  globalMarkers.push(m);
  // keep last 300 markers
  if(globalMarkers.length > 300) globalMarkers = globalMarkers.slice(-300);
  try{ series.setMarkers(globalMarkers); }catch(e){ /* ignore chart error */ }
}
function addSignalMarker(text, type, time){
  pushMarker({
    time: time,
    position: type==='long' ? 'belowBar' : 'aboveBar',
    color: type==='long' ? 'green' : 'red',
    shape: type==='long' ? 'arrowUp' : 'arrowDown',
    text: text
  });
  // also add to log
  log(`${new Date(time*1000).toLocaleString()} • ${text}`);
}

// ======== ALERT DEBOUNCE (avoid repeat spamming) ========
const lastAlert = {}; // key -> timestamp
function alertOnce(key, cb){
  const now = Date.now();
  const cooldown = 5*60*1000; // 5 min per key
  if(lastAlert[key] && (now - lastAlert[key] < cooldown)) return;
  lastAlert[key] = now;
  if(typeof cb === 'function') cb();
}

// ======== BREAKOUT DETECTOR (simple) ========
function detectBreakoutSimple(closes, klines){
  const recent = closes.slice(-20);
  const high = Math.max(...recent);
  const low = Math.min(...recent);
  const last = closes[closes.length-1];
  const lastTime = klines[klines.length-1][0]/1000;
  const firstTime = klines[klines.length-20][0]/1000 || klines[0][0]/1000;
  if(last > high){
    // draw horizontal resistance line across recent window
    resistanceSeries.setData([{ time: firstTime, value: high }, { time: lastTime, value: high }]);
    return { type: 'Breakout', value: high, time: lastTime };
  }
  if(last < low){
    supportSeries.setData([{ time: firstTime, value: low }, { time: lastTime, value: low }]);
    return { type: 'Breakdown', value: low, time: lastTime };
  }
  // clear small drawings if none
  supportSeries.setData([]);
  resistanceSeries.setData([]);
  return null;
}

// ======== HISTORY & LOG ========
DOM('#clearHistory').onclick=()=>{ localStorage.removeItem('zain_history'); renderHistory(); };
DOM('#downloadHistory').onclick=()=>{
  const data = localStorage.getItem('zain_history')||'[]';
  const blob = new Blob([data], { type:'application/json' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='history.json'; a.click();
};
function saveHistory(results){
  const hist = JSON.parse(localStorage.getItem('zain_history')||'[]');
  hist.push({ time: new Date().toISOString(), results });
  localStorage.setItem('zain_history', JSON.stringify(hist));
  renderHistory();
}
function renderHistory(){
  const hist = JSON.parse(localStorage.getItem('zain_history')||'[]');
  DOM('#history').innerText = JSON.stringify(hist, null, 2);
}
function log(msg){
  const el = DOM('#log');
  el.innerText += (new Date()).toLocaleTimeString() + ' - ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}

// ======== RENDER results list ========
function renderResults(results){
  const filter = DOM('#filter').value;
  const q = DOM('#search').value.trim().toUpperCase();
  const list = DOM('#list'); list.innerHTML='';
  DOM('#kpis').innerHTML = `<div class="small muted">Hasil: ${results.length}</div>`;
  for(const r of results){
    if(filter!=='all' && ((filter==='long' && !r.long) || (filter==='short' && !r.short))) continue;
    if(q && !r.symbol.includes(q)) continue;
    const div = document.createElement('div'); div.className='coin';
    div.innerHTML = `<div>${r.symbol} <span class="pill ${r.long?'long':r.short?'short':'neutral'}">${r.long?'LONG':r.short?'SHORT':'NEUTRAL'}</span></div>
      <div>Price: ${fmt(r.lastPrice)}</div>
      <div>SL: ${fmt(r.stopLoss)}, TP1: ${fmt(r.tp1)}, TP2: ${fmt(r.tp2)}, TP3: ${fmt(r.tp3)}</div>
      <div>Size: ${fmt(r.positionSize)}</div>
      <div class="signal-desc">${r.reason}</div>
      ${r.fibLevels && r.fibLevels.length?`<div class="signal-desc">Fibonacci: ${r.fibLevels.map(f=>fmt(f)).join(', ')}</div>`:''}`;
    list.appendChild(div);
  }
}

// ======== SCAN flow ========
let intervalId = null;
DOM('#startBtn').onclick = ()=>{ unlockAudioOnce(); startScan(); };
DOM('#stopBtn').onclick = ()=>{ clearInterval(intervalId); DOM('#status').innerText='Stopped'; log('Stopped by user'); };

// Start scan (sets auto-refresh)
function startScan(){
  clearInterval(intervalId);
  // start immediately
  runScan().catch(e=>log('runScan error: '+(e && e.message ? e.message : e)));
  // schedule periodic (every 5 minutes)
  intervalId = setInterval(()=>{ runScan().catch(e=>log('runScan error: '+(e && e.message ? e.message : e))); }, 5*60*1000);
  DOM('#status').innerText='Auto scanning every 5 minutes';
}

// The main async scanner
async function runScan(){
  initChart();
  DOM('#status').innerText='Scanning...';
  log('Start scan');

  const tf = DOM('#tf').value;
  const limit = +DOM('#limit').value;
  const topN = +DOM('#topN').value;
  const capital = +DOM('#capital').value;
  const risk = +DOM('#risk').value;
  const useEMA = DOM('#useEMA').checked, useRSI = DOM('#useRSI').checked, useMACD = DOM('#useMACD').checked, useBB = DOM('#useBB').checked, useFIB = DOM('#useFIB').checked;

  let tickers;
  try{
    tickers = await tryFetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
  }catch(e){
    DOM('#warn').innerText = 'Gagal ambil ticker: ' + (e && e.message ? e.message : e);
    DOM('#status').innerText='Idle';
    log('Failed to fetch tickers: '+(e && e.message ? e.message : e));
    return;
  }

  // filter pairs ending with USDT and sort by quoteVolume
  const usdt = tickers.filter(t=>t.symbol && t.symbol.endsWith('USDT'));
  usdt.sort((a,b)=> +b.quoteVolume - +a.quoteVolume);
  const coins = usdt.slice(0, Math.max(1, Math.min(topN, usdt.length)));
  if(!coins.length){ DOM('#warn').innerText='No USDT pairs found'; DOM('#status').innerText='Idle'; return; }

  const results = [];
  // iterate sequentially to avoid hitting API rate limit
  for(let i=0;i<coins.length;i++){
    const c = coins[i];
    const symbol = c.symbol;
    try{
      const klines = await tryFetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`);
      if(!Array.isArray(klines) || klines.length < 50){ log(symbol + ' insufficient klines'); continue; }
      const closes = klines.map(k=>+k[4]);
      const highs = klines.map(k=>+k[2]);
      const lows = klines.map(k=>+k[3]);
      const ema50arr = EMA(closes,50), ema200arr = EMA(closes,200);
      const rsiarr = RSI(closes), macdobj = MACD(closes), bbarr = BB(closes);
      const lastPrice = closes[closes.length-1];

      let long=false, short=false;
      let reasonArr = [];

      // Golden Cross / Death Cross
      if(useEMA){
        const prev50 = ema50arr[ema50arr.length-2], prev200 = ema200arr[ema200arr.length-2];
        const now50 = ema50arr[ema50arr.length-1], now200 = ema200arr[ema200arr.length-1];
        if(Number.isFinite(prev50) && Number.isFinite(prev200) && Number.isFinite(now50) && Number.isFinite(now200)){
          if(prev50 < prev200 && now50 > now200){
            long = true; reasonArr.push('Golden Cross');
            alertOnce(symbol + '|goldencross', ()=>{ addSignalMarker('Golden Cross', 'long', klines[klines.length-1][0]/1000); playAlarm(); });
          }
          if(prev50 > prev200 && now50 < now200){
            short = true; reasonArr.push('Death Cross');
            alertOnce(symbol + '|deathcross', ()=>{ addSignalMarker('Death Cross', 'short', klines[klines.length-1][0]/1000); playAlarm(); });
          }
        }
      }

      // RSI extreme (only alarm if extreme)
      if(useRSI){
        const rsiNow = rsiarr[rsiarr.length-1];
        if(Number.isFinite(rsiNow)){
          if(rsiNow < 20){
            long = true; reasonArr.push('RSI very oversold');
            alertOnce(symbol + '|rsi-oversold', ()=>{ addSignalMarker('RSI Oversold <20', 'long', klines[klines.length-1][0]/1000); playAlarm(); });
          }
          if(rsiNow > 80){
            short = true; reasonArr.push('RSI very overbought');
            alertOnce(symbol + '|rsi-overbought', ()=>{ addSignalMarker('RSI Overbought >80', 'short', klines[klines.length-1][0]/1000); playAlarm(); });
          }
        }
      }

      // MACD quick bias tag (no alarm)
      if(useMACD){
        const macdNow = macdobj.macd[macdobj.macd.length-1], sigNow = macdobj.sig[macdobj.sig.length-1];
        if(Number.isFinite(macdNow - sigNow)){
          if(macdNow - sigNow > 0) reasonArr.push('MACD bullish');
          else if(macdNow - sigNow < 0) reasonArr.push('MACD bearish');
        }
      }

      // Fibonacci detection (golden levels) -> 0.618 & 0.786
      let fibLevels = [];
      if(useFIB){
        const swingHigh = Math.max(...highs.slice(-50));
        const swingLow = Math.min(...lows.slice(-50));
        fibLevels = [0,0.236,0.382,0.5,0.618,0.786,1].map(f => swingLow + (swingHigh - swingLow) * f);
        // check proximity to 0.618 or 0.786 (tolerance = 0.25% of price)
        const tol = Math.max( (swingHigh - swingLow) * 0.001, lastPrice * 0.0025 );
        if(Math.abs(lastPrice - fibLevels[4]) <= tol){
          reasonArr.push('Golden Fibonacci 0.618');
          alertOnce(symbol + '|fibo618', ()=>{ addSignalMarker('Golden Fibonacci 0.618','long',klines[klines.length-1][0]/1000); playAlarm(); });
        }
        if(Math.abs(lastPrice - fibLevels[5]) <= tol){
          reasonArr.push('Golden Fibonacci 0.786');
          alertOnce(symbol + '|fibo786', ()=>{ addSignalMarker('Golden Fibonacci 0.786','long',klines[klines.length-1][0]/1000); playAlarm(); });
        }
      }

      // Breakout / Breakdown simple detector
      const breakout = detectBreakoutSimple(closes, klines);
      if(breakout){
        reasonArr.push(breakout.type);
        // mark line & marker (no alarm)
        addSignalMarker(breakout.type, breakout.type==='Breakout' ? 'long' : 'short', breakout.time);
      }

      // Money management estimates (same as template)
      const stopLoss = long ? lastPrice * 0.98 : lastPrice * 1.02;
      const tp1 = long ? lastPrice * 1.02 : lastPrice * 0.98;
      const tp2 = long ? lastPrice * 1.04 : lastPrice * 0.96;
      const tp3 = long ? lastPrice * 1.06 : lastPrice * 0.94;
      const positionSize = Math.abs((capital * (risk/100)) / (lastPrice - stopLoss || lastPrice)); // safe divide

      results.push({
        symbol, lastPrice, long, short,
        stopLoss, tp1, tp2, tp3, positionSize,
        reason: reasonArr.join('; '), fibLevels
      });

      // update chart for top coin only (first in list)
      if(i === 0){
        const ohlc = klines.map(k => ({ time: k[0]/1000, open:+k[1], high:+k[2], low:+k[3], close:+k[4] }));
        series.setData(ohlc);
        // ema series mapping to times (filter non-finite)
        const ema50Data = ema50arr.map((v, idx) => ({ time: klines[idx][0]/1000, value: Number.isFinite(v) ? v : null })).filter(x=>x.value);
        const ema200Data = ema200arr.map((v, idx) => ({ time: klines[idx][0]/1000, value: Number.isFinite(v) ? v : null })).filter(x=>x.value);
        ema50Series.setData(ema50Data);
        ema200Series.setData(ema200Data);
        if(useBB){
          const bbDataUp = bbarr.map((b, idx) => b ? { time: klines[idx][0]/1000, value: b.upper } : null).filter(Boolean);
          const bbDataLow = bbarr.map((b, idx) => b ? { time: klines[idx][0]/1000, value: b.lower } : null).filter(Boolean);
          bbUpper.setData(bbDataUp);
          bbLower.setData(bbDataLow);
        } else { bbUpper.setData([]); bbLower.setData([]); }
        if(useFIB && results[0] && results[0].fibLevels && results[0].fibLevels.length){
          DOM('#chartInfo').innerText = `Chart: ${symbol} • Fibo[0.618,0.786]: ${fmt(results[0].fibLevels[4])}, ${fmt(results[0].fibLevels[5])}`;
        } else {
          DOM('#chartInfo').innerText = `Chart: ${symbol}`;
        }
      }

      // small delay to avoid hammering API
      await sleep(120);
    }catch(err){
      log(`Error for ${symbol}: ${err && err.message ? err.message : err}`);
      // continue to next symbol
    }
  } // end for

  renderResults(results);
  saveHistory(results);
  DOM('#status').innerText='Idle';
  log('Scan finished');
}

// ======== EXPORT handlers (CSV/JSON) ========
DOM('#exportCSV').addEventListener('click', ()=>{
  const hist = JSON.parse(localStorage.getItem('zain_history')||'[]');
  const last = hist.slice(-1)[0];
  if(!last || !last.results){ alert('Tidak ada data untuk diekspor'); return; }
  const rows = [['symbol','direction','entry','stopLoss','tp1','tp2','tp3','rr1','positionSize']];
  last.results.forEach(r=>{
    rows.push([r.symbol, (r.long?'LONG':r.short?'SHORT':'NEUTRAL'), '', r.stopLoss, r.tp1, r.tp2, r.tp3, '', r.positionSize]);
  });
  const csv = rows.map(r => r.join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='scan.csv'; a.click();
});
DOM('#exportJSON').addEventListener('click', ()=>{
  const data = localStorage.getItem('zain_history') || '[]';
  const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='history.json'; a.click();
});

// initialize UI
renderHistory();
initChart();
log('UI ready — tekan Start Scan untuk memulai (klik Start sekali untuk mengizinkan alarm).');

</script>
</body>
</html>
